#!/usr/bin/python3 -u
import base64
import hashlib
import http.server
import io
import json
import os
import subprocess
import struct
import tarfile
import time
import traceback

import Cryptodome.Cipher.AES

# automatically turn the display off to save power
subprocess.check_call(['setterm', '--powerdown', '1', '--blank', '1'])

# read config from kernel cmdline
print(f"reading config from kernel cmdline")

with open('/proc/cmdline') as cmdlinefile:
    cmdline = cmdlinefile.read()
cmdlineargs = {}
for entry in cmdline.strip().split():
    try:
        key, value = entry.split('=', maxsplit=1)
        cmdlineargs[key] = value
    except ValueError:
        continue

print(f"config: {cmdlineargs}")

# challenge for clients to prevent replay attacks
CHALLENGE = base64.b64encode(os.urandom(16)).decode('ascii')

IPCFG = cmdlineargs['stiefel_srvip']
BLKDEV = cmdlineargs["stiefel_bootdisk"]
BOOTPART = cmdlineargs["stiefel_bootpart"]
KERNEL = cmdlineargs["stiefel_kernel"]
INITRD = cmdlineargs["stiefel_initrd"]
NOCRYPTO = bool(int(cmdlineargs.get("stiefel_nocrypto", "0")))
MACS = set()
for mac in cmdlineargs["stiefel_srvmacs"].split(','):
    mac = mac.strip()
    if mac:
        MACS.add(mac)

def attempt_netcfg():
    for netdev in os.listdir('/sys/class/net'):
        with open(f'/sys/class/net/{netdev}/address') as macfile:
            mac = macfile.read().strip()
        if mac in MACS:
            print(f"network interface found: {mac} {netdev}")
            print(f"attempting to configure it with {IPCFG}")
            # interface found
            try:
                print(f"configuring network: {IPCFG} on {mac} {netdev}")
                time.sleep(1)
                subprocess.check_call(['ip', 'l', 'set', 'up', netdev])
                time.sleep(0.1)
                subprocess.check_call(['ip', 'a', 'a', IPCFG, 'dev', netdev])
                subprocess.check_call(['ip', 'r', 'a', 'default', 'dev', netdev])
                return True
            except BaseException:
                print("could not configure network")
    return False

# wait for network interface to be available
for i in range(10000):
    if i % 250 == 0:
        print(f"waiting for network interface: ({', '.join(MACS)})")

    if attempt_netcfg():
        break
    else:
        time.sleep(0.02)
else:
    # no interface found
    raise ValueError("could not find network device")

# TODO: notice when the interface goes down, then restart this script
# TODO: allow other methods than NBD

# create NBD config
with open("/etc/nbd-server/config", "w") as nbdconfigfile:
    nbdconfigfile.write(
        f"""
        [generic]
        [stiefelblock]
        exportname = {BLKDEV}
        copyonwrite = false
        """
    )

# open NBD server
print(f"opening NBD server for {BLKDEV}")
subprocess.check_call(['systemctl', 'start', 'nbd-server'])

def get_boot_tar(challenge):
    print("packing kernel and initrd")
    # read the kernel and initrd
    subprocess.check_call(['mount', '-oro', BOOTPART, '/mnt'])
    with open(f'/mnt/{KERNEL}', 'rb') as fileobj:
        kernelblob = fileobj.read()
    with open(f'/mnt/{INITRD}', 'rb') as fileobj:
        initrdblob = fileobj.read()
    subprocess.check_call(['umount', '/mnt'])
    # create the response TAR in-memory
    with io.BytesIO() as fileobj:
        with tarfile.open(fileobj=fileobj, mode='w') as tar:
            tf = tarfile.TarInfo('kernel')
            tf.size = len(kernelblob)
            tar.addfile(tf, io.BytesIO(kernelblob))
            tf = tarfile.TarInfo('initrd')
            tf.size = len(initrdblob)
            tar.addfile(tf, io.BytesIO(initrdblob))
            tf = tarfile.TarInfo('challenge')
            tf.size = len(challenge)
            tar.addfile(tf, io.BytesIO(challenge))
        fileobj.seek(0)
        return fileobj.read()

# run HTTP server
print("running HTTP server")
def handle_request(path):
    if path == '/':
        return 200, json.dumps({
            "what": "stiefelsystem-server",
            "args": cmdlineargs,
            "challenge": CHALLENGE,
        }, indent=4)
    elif path == '/boot.tar':
        if NOCRYPTO:
            return 200, get_boot_tar(b'')
        else:
            return 503, "only boot.tar.aes is available"
    elif path.startswith('/boot.tar.aes?challenge='):
        # the client shall supply a random challenge to prevent replay
        # attacks that would cause the boot of an older kernel/initrd.
        plaintext = get_boot_tar(challenge=path.encode('utf-8'))
        with open('/aeskey', 'rb') as keyfile:
            key = keyfile.read()
        nonce_gen = hashlib.sha256(plaintext)  # recommended by djb lol
        nonce_gen.update(os.urandom(16))
        nonce = nonce_gen.digest()[:16]
        cipher = Cryptodome.Cipher.AES.new(
            key,
            Cryptodome.Cipher.AES.MODE_EAX,
            nonce=nonce,
            mac_len=16
        )
        print('encrypting boot.tar.aes')
        ciphertext, mac = cipher.encrypt_and_digest(plaintext)
        print('encryption done')
        if len(mac) != 16:
            raise ValueError('bad MAC length')
        del plaintext
        return 200, nonce + ciphertext + mac
    else:
        return 404, f"404: {path}"

class RequestHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        try:
            code, message = handle_request(self.path)
        except Exception as exc:
            traceback.print_exc()
            code, message = 503, f"internal server error: {exc}"

        if isinstance(message, str):
            print(f"sending text reply: {message!r}")
            message = message.encode('utf-8')
            content_type = "text/plain; charset=utf-8"
        else:
            print(f"sending binary reply: {len(message)} bytes")
            content_type = "application/x-binary"

        self.protocol_version = "HTTP/1.1"
        self.send_response(code)
        self.send_header("Content-Length", len(message))
        self.send_header("Content-Type", content_type)
        self.end_headers()

        self.wfile.write(message)

with open('/etc/hostname') as hostnamefile:
    hostname = hostnamefile.read().strip()
with open('/etc/hosts', 'a') as hostsfile:
    hostsfile.write(f'{IPCFG.split("/")[0]} {hostname}\n')

http.server.HTTPServer(('', 80), RequestHandler).serve_forever()
