#!/usr/bin/env python3
"""
script to test the server and client in qemu.

run this in two terminals.
first you need to start the server:

sudo ./qemu server

then, run

sudo ./qemu client

they should be able to talk to each other.
the client should download the kernel and initrd from the server,
and proceed up to `kexec`.
"""
import argparse
import base64
import contextlib
import json
import os
import tempfile

from config import CONFIG as cfg
from util import (
    command,
    ensure_root,
)

ensure_root()

cli = argparse.ArgumentParser()
cli.add_argument('--kernel', default=cfg.path.initrd + '/vmlinuz')
cli.add_argument('--initrd', default=cfg.path.cpio)
cli.add_argument('mode')
cli.add_argument('--forward-usb')
cli.add_argument('--graphical', action='store_true')
cli.add_argument('--skip-confirm', action='store_true')
cli.add_argument('--extra-files')
args = cli.parse_args()

with contextlib.ExitStack() as exit_stack:
    tmpdir = exit_stack.enter_context(tempfile.TemporaryDirectory())
    def tmppath(name):
        return os.path.join(tmpdir, name)

    if args.mode == 'client':
        # client mode only works when a server is already running
        mac = "52:54:00:5f:70:02"


        inner_cmdline = base64.b64encode(" ".join([
            "lol",
            "wtf"
        ]).encode('utf-8')).decode('ascii')

        cmdline = [
            "systemd.unit=stiefel-client.service",
            "nomodeset",
            "stiefel_innercmdline=" + inner_cmdline,
        ]
        qemu_args = []
    elif args.mode == 'server':
        mac = "52:54:00:5f:70:03"

        with contextlib.ExitStack() as setup_exit_stack:

            # 4 GiB sparse image
            disk_size = 2**32

            # create the disk image that will be served to the server
            with open(tmppath('loop_file'), 'wb') as loop_file:
                loop_file.truncate(disk_size)

            # create partitions in loop file
            command(
                'sfdisk', loop_file.name,
                stdin=f'label: dos\n2048,{(disk_size // 512) - 2048},c,*\n'
            )
            # create the loop device
            loop_device_name = command(
                'losetup', '-fP', '--show', loop_file.name,
                capture_stdout=True
            )
            loop_device_name = loop_device_name.decode().strip()
            setup_exit_stack.callback(
                lambda: command('losetup', '-d', loop_device_name))
            bootpartition_name = loop_device_name + 'p1'

            bootpart_luks = None
            if cfg.boot.luks_block is not None:
                luks_password = "sft.lol"
                command('cryptsetup', 'luksFormat', bootpartition_name, '-',
                        stdin=f'{luks_password}\n')

                luks_mapped_name = 'stiefel-qemu-root'
                command('cryptsetup', 'open', '--type=luks', '--key-file=-',
                        bootpartition_name, luks_mapped_name,
                        stdin=f'{luks_password}\n')
                setup_exit_stack.callback(
                    lambda: command('cryptsetup', 'close', luks_mapped_name))

                bootpart_luks = bootpartition_name
                bootpartition_name = f'/dev/mapper/{luks_mapped_name}'

            if 'lvm' in cfg.modules:
                command('pvcreate', bootpartition_name)
                pv_device = bootpartition_name
                setup_exit_stack.callback(
                    lambda: command('pvremove', pv_device))

                vg_name = 'qemustiefel'
                command('vgcreate', vg_name, bootpartition_name)
                setup_exit_stack.callback(
                    lambda: command('vgremove', vg_name))

                setup_exit_stack.callback(
                    lambda: command('cp', '--sparse=always',
                                    loop_file.name, tmppath('disk_image')))

                setup_exit_stack.callback(
                    lambda: command('vgchange', '--activate=n', vg_name))

                command('lvcreate', '-n', 'boot', '-L', '1G', vg_name)
                command('lvcreate', '-n', 'root', '-L', '2G', vg_name)

                command('mkfs.ext4', '/dev/mapper/qemustiefel-root')

                bootpartition_name = '/dev/mapper/qemustiefel-boot'

            else:
                setup_exit_stack.callback(
                    lambda: command('mv', loop_file.name, tmppath('disk_image')))

            # create filesystem on the partition
            command('mkfs.vfat', '-F', '16', bootpartition_name)

            # mount filesystem, fill it with files, and unmount it
            os.makedirs(tmppath('mountpoint'), exist_ok=True)
            command('mount', bootpartition_name, tmppath('mountpoint'))
            setup_exit_stack.callback(
                lambda: command('umount', tmppath('mountpoint')))

            command('cp', args.kernel, tmppath('mountpoint') + '/kernel')
            command('cp', args.initrd, tmppath('mountpoint') + '/initrd')

            with open(tmppath('mountpoint') + '/stiefelsystem.json', 'w') as fileobj:
                json.dump({"kernel": "kernel", "initrd": "initrd"}, fileobj)

        # setup the bridge that allows connection to the client VM
        command('ip', 'link', 'add', 'name', 'br0', 'type', 'bridge')
        command('ip', 'link', 'set', 'dev', 'br0', 'up')
        command('ip', 'a', 'a', '10.4.5.1/24', 'dev', 'br0')
        exit_stack.callback(lambda: command('ip', 'link', 'delete', 'br0'))

        # because inside qemu the loop-device is called vda
        if bootpartition_name == loop_device_name + 'p1':
            bootpartition_name = "/dev/vda1"

        if bootpart_luks == loop_device_name + 'p1':
            bootpart_luks = "/dev/vda1"

        cmdline = [
            "systemd.unit=stiefel-server.service",
            "stiefel_bootdisk=/dev/vda",
            f"stiefel_bootpart={bootpartition_name}",
        ]

        if cfg.boot.luks_block is not None:
            cmdline.append(
                f'stiefel_bootpart_luks={bootpart_luks}'
            )

        qemu_args = [
            "-drive", f"file={tmppath('disk_image')},format=raw,if=virtio"
        ]

    elif args.mode == 'test':
        mac = "52:54:00:5f:70:04"

        # network link makes sense to have even in the test vm
        command('ip', 'link', 'add', 'name', 'br0', 'type', 'bridge')
        command('ip', 'link', 'set', 'dev', 'br0', 'up')
        command('ip', 'a', 'a', '10.4.5.1/24', 'dev', 'br0')
        exit_stack.callback(lambda: command('ip', 'link', 'delete', 'br0'))

        cmdline = []
        qemu_args = []

    else:
        cli.error("mode must be 'client', 'server' or 'test'")

    with open(tmppath('ifup-script'), 'w') as ifup_script:
        ifup_script.writelines([
            "#!/bin/sh\n",
            "ip l set $1 up\n",
            "ip l set dev $1 master br0\n",
            "ip l set br0 up\n",
        ])
    os.chmod(tmppath('ifup-script'), 0o755)

    if args.forward_usb is not None:
        try:
            vid, did = args.forward_usb.split(':')
            if len(vid) != 4 or len(did) != 4:
                raise ValueError()
        except ValueError:
            cli.error("--forward-usb expects VID:DID")

        qemu_args.extend([
            "-usb",
            "-device", f"usb-host,vendorid=0x{vid},productid=0x{did}"
        ])

    if not args.graphical:
        cmdline.insert(0, "console=ttyS0")
        qemu_args.append("-nographic")

        print("quit qemu with C-A X")
        if not args.skip_confirm and not args.graphical:
            print("press ENTER to enter simulation")
            input()

    if args.extra_files is not None:
        # pack the extra files into an CPIO archive
        extra_cpio = command(
            "find . -depth -print0 | bsdcpio -0 -o -H newc | gzip -1",
            shell=True,
            cwd=args.extra_files,
            capture_stdout=True,
            env={"LANG": "C"},
        )
        with open(args.initrd, 'rb') as initrd_rfile:
            args.initrd = tmppath('initrd-concatenated')
            with open(args.initrd, 'wb') as initrd_wfile:
                initrd_wfile.write(initrd_rfile.read())
                initrd_wfile.write(extra_cpio)

    command(
        "qemu-system-x86_64",
        "-machine", "q35,accel=kvm",
        "-m", "10240",
        "-kernel", args.kernel,
        "-initrd", args.initrd,
        "-netdev", f"tap,id=network0,script={tmppath('ifup-script')},downscript=no",
        "-device", f"virtio-net,netdev=network0,mac={mac}",
        "-append", " ".join(cmdline),
        *qemu_args
    )
